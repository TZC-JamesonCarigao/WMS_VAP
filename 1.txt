#admin.py
from django.contrib import admin
from .models import VAPProductionData, ProductData, SourceData, ProductionDescription


@admin.register(VAPProductionData)
class VAPProductionDataAdmin(admin.ModelAdmin):
    list_display = ('Date', 'PlantLoc', 'Shift', 'get_product_name', 'TimeStart', 'TimeEnd', 'Total')
    list_filter = ('Date', 'PlantLoc', 'Shift', 'Product')
    search_fields = ('Product__Product', 'ProdMinDescrip__ProdMinDes')
    ordering = ('-Date', '-TimeStart')

    def get_product_name(self, obj):
        return obj.Product.Product if obj.Product else '-'
    get_product_name.short_description = 'Product'


@admin.register(ProductData)
class ProductDataAdmin(admin.ModelAdmin):
    list_display = ('Product',)
    search_fields = ('Product',)


@admin.register(SourceData)
class SourceDataAdmin(admin.ModelAdmin):
    list_display = ('Source',)
    search_fields = ('Source',)


@admin.register(ProductionDescription)
class ProductionDescriptionAdmin(admin.ModelAdmin):
    list_display = ('SecID', 'ProdMinDes')
    search_fields = ('ProdMinDes',)


#forms.py
from django import forms
from django.core.exceptions import ValidationError
from .models import VAPProductionData, ProductData, SourceData, ProductionDescription
import datetime

class VAPProductionDataForm(forms.ModelForm):
    Total = forms.CharField(widget=forms.HiddenInput(), required=False)

    class Meta:
        model = VAPProductionData
        fields = '__all__'
        widgets = {
            'Date': forms.DateInput(attrs={'type': 'date'}),
            'TimeStart': forms.TimeInput(attrs={'type': 'time'}),
            'TimeEnd': forms.TimeInput(attrs={'type': 'time'}),
            'ProdMinDescrip': forms.Select(attrs={'class': 'form-control'}),
            'Source': forms.Select(attrs={'class': 'form-control'}),
            'Product': forms.Select(attrs={'class': 'form-control'}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['Date'].initial = datetime.date.today()
        self.fields['PlantLoc'].initial = 'PULILAN'
        self.fields['Shift'].initial = 'DAY SHIFT'

    def clean(self):
        cleaned_data = super().clean()
        time_start = cleaned_data.get('TimeStart')
        time_end = cleaned_data.get('TimeEnd')

        if time_start and time_end:
            if time_start == time_end:
                raise ValidationError("Start time and end time cannot be the same")

            record = VAPProductionData(TimeStart=time_start, TimeEnd=time_end)
            cleaned_data['Total'] = record.calculate_total_time()

        return cleaned_data

class ImportForm(forms.Form):
    excel_file = forms.FileField(
        label='Select Excel file to import',
        help_text='The Excel file should match the export format'
    )


class ProductionForm(forms.ModelForm):
    Product = forms.ModelChoiceField(
        queryset=ProductData.objects.all()[:1000],
        empty_label="Select a Product",
        widget=forms.Select(attrs={'class': 'form-control'})
    )

    Source = forms.ModelChoiceField(
        queryset=SourceData.objects.all()[:1000],
        empty_label="Select a Source",
        widget=forms.Select(attrs={'class': 'form-control'})
    )

    ProdMinDescrip = forms.ModelChoiceField(
        queryset=ProductionDescription.objects.all()[:1000],
        empty_label="Select a Description",
        widget=forms.Select(attrs={'class': 'form-control'})
    )

    class Meta:
        model = VAPProductionData
        fields = '__all__'


#models.py
from django.db import models

class ProductData(models.Model):
    Product = models.CharField(max_length=255)

    class Meta:
        db_table = 'ProductData'
        managed = False

    def __str__(self):
        return self.Product

class SourceData(models.Model):
    Source = models.CharField(max_length=255)

    class Meta:
        db_table = 'SourceData'
        managed = False

    def __str__(self):
        return self.Source

class ProductionDescription(models.Model):
    SecID = models.IntegerField()
    ProdMinDes = models.CharField(max_length=255)

    class Meta:
        db_table = 'Production_Description'
        managed = False

    def __str__(self):
        return self.ProdMinDes

class VAPProductionData(models.Model):
    PLANT_CHOICES = [
        ('PULILAN', 'Pulilan'),
        ('TARLAC', 'Tarlac'),
    ]
    
    SHIFT_CHOICES = [
        ('DAY SHIFT', 'Day Shift'),
        ('NIGHT SHIFT', 'Night Shift'),
    ]
    
    ID = models.AutoField(primary_key=True)
    Date = models.DateField(db_column='Date')
    PlantLoc = models.CharField(max_length=255, choices=PLANT_CHOICES, null=True, db_column='PlantLoc')
    Shift = models.CharField(max_length=255, choices=SHIFT_CHOICES, null=True, db_column='Shift')
    Product = models.ForeignKey(ProductData, on_delete=models.SET_NULL, null=True, db_column='Product')
    TimeStart = models.TimeField(db_column='TimeStart')
    TimeEnd = models.TimeField(db_column='TimeEnd')
    Total = models.CharField(max_length=100, db_column='Total')
    ProdMinDescrip = models.ForeignKey(ProductionDescription, on_delete=models.SET_NULL, null=True, db_column='ProdMinDescrip')
    BoilerTemp = models.IntegerField(db_column='BoilerTemp')
    CookingOilTemp = models.DecimalField(max_digits=5, decimal_places=2, db_column='CookingOilTemp')
    MetersPerMin = models.IntegerField(null=True, db_column='MetersPerMin')
    OutputTemp = models.DecimalField(max_digits=5, decimal_places=2, db_column='OutputTemp')
    InputTemp = models.DecimalField(max_digits=5, decimal_places=2, db_column='InputTemp')
    Source = models.ForeignKey(SourceData, on_delete=models.SET_NULL, null=True, db_column='Source')
    FormaticStrokeMin = models.IntegerField(db_column='FormaticStrokeMin')
    Section = models.CharField(max_length=255, null=True, db_column='Section')
    MonthYear = models.CharField(max_length=255, null=True, db_column='MonthYear')
    
    class Meta:
        db_table = 'VAPProductionData'
        ordering = ['-Date', '-TimeStart']
    
    def __str__(self):
        return f"{self.Date} - {self.Shift} - {self.Product}"
    
    def save(self, *args, **kwargs):
        if self.TimeStart and self.TimeEnd:
            self.Total = self.calculate_total_time()
        super().save(*args, **kwargs)
    
    def calculate_total_time(self):
        start_total_minutes = self.TimeStart.hour * 60 + self.TimeStart.minute
        end_total_minutes = self.TimeEnd.hour * 60 + self.TimeEnd.minute
        total_minutes = end_total_minutes - start_total_minutes
        if total_minutes < 0:
            total_minutes += 24 * 60
        display_hr = total_minutes // 60
        display_min = total_minutes % 60
        return f"{int(display_hr)} hr {int(display_min):02} min"


#views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.views.generic import ListView, CreateView, UpdateView, DeleteView, FormView
from django.urls import reverse_lazy
from django.contrib import messages
from django.http import HttpResponse
from django.db.models import Sum, Count
from datetime import datetime, timedelta
import pandas as pd
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows

from .models import VAPProductionData, ProductData, SourceData, ProductionDescription   # Updated import
from .forms import VAPProductionDataForm, ImportForm, ProductionForm  # Note: You might want to rename this form too
from django.core.exceptions import FieldError

from copy import copy
from django.conf import settings
import os

from openpyxl import load_workbook


class ProductionRecordListView(ListView):
    model = VAPProductionData  # Updated model reference
    template_name = 'report_list.html'
    context_object_name = 'records'
    paginate_by = 20
    ordering = ['-Date', '-TimeStart']  # Updated field names

    def get_queryset(self):
        queryset = super().get_queryset()

        # Date range filtering
        start_date = self.request.GET.get('start_date')
        end_date = self.request.GET.get('end_date')

        if start_date and end_date:
            queryset = queryset.filter(Date__range=[start_date, end_date])  # Updated field name

        return queryset

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['start_date'] = self.request.GET.get('start_date', '')
        context['end_date'] = self.request.GET.get('end_date', '')
        return context


# class ProductionRecordCreateView(CreateView):
#     model = VAPProductionData  # Updated model reference
#     form_class = VAPProductionDataForm
#     template_name = 'create.html'
#     success_url = reverse_lazy('report_list')

#     def form_valid(self, form):
#         response = super().form_valid(form)
#         messages.success(self.request, 'Production record created successfully!')
#         return response

class ProductionRecordCreateView(CreateView):
    model = VAPProductionData
    form_class = VAPProductionDataForm
    template_name = 'create.html'
    success_url = reverse_lazy('report_list')

    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, 'Production record created successfully!')
        return response

class ProductionRecordUpdateView(UpdateView):
    model = VAPProductionData  # Updated model reference
    form_class = VAPProductionDataForm
    template_name = 'edit.html'
    success_url = reverse_lazy('report_list')

    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, 'Production record updated successfully!')
        return response


class ProductionRecordDeleteView(DeleteView):
    model = VAPProductionData  # Updated model reference
    template_name = 'delete.html'
    success_url = reverse_lazy('report_list')

    def delete(self, request, *args, **kwargs):
        response = super().delete(request, *args, **kwargs)
        messages.success(self.request, 'Production record deleted successfully!')
        return response


def dashboard_view(request):
    context = {
        'total_records': VAPProductionData.objects.count(),  # Updated model reference
        'recent_records': VAPProductionData.objects.order_by('-Date', '-TimeStart')[:10],  # Updated field names
    }

    try:
        product_distribution = (
            VAPProductionData.objects  # Updated model reference
            .values('Product')  # Updated field name
            .annotate(count=Count('id'), total=Sum('FormaticStrokeMin'))  # Updated field name
            .order_by('-total')
        )
        
        context['product_distribution'] = {
            'labels': [item['Product'] for item in product_distribution],  # Updated field name
            'values': [float(item['total']) for item in product_distribution]
        }
    except FieldError:
        context['product_distribution'] = {
            'labels': ['Unknown'],
            'values': [0]
        }

    context['trend_data'] = {
        'dates': [], 
        'values': []
    }
    
    return render(request, 'dashboard.html', context)

def export_to_excel(request):
    try:
        start_date = request.GET.get('start_date')
        end_date = request.GET.get('end_date')

        queryset = VAPProductionData.objects.all()
        if start_date:
            queryset = queryset.filter(Date__gte=start_date)
        if end_date:
            queryset = queryset.filter(Date__lte=end_date)

        records = queryset.values(
            'ID', 'Date', 'PlantLoc', 'Shift', 'Product', 'TimeStart', 'TimeEnd',
            'Total', 'ProdMinDescrip', 'BoilerTemp', 'CookingOilTemp',
            'OutputTemp', 'InputTemp', 'Source', 'FormaticStrokeMin'
        )

        df = pd.DataFrame.from_records(records)

        # Map display choices (correct field names)
        df['PlantLoc'] = df['PlantLoc'].map(dict(VAPProductionData.PLANT_CHOICES))
        df['Shift'] = df['Shift'].map(dict(VAPProductionData.SHIFT_CHOICES))

        # ==== Utility Functions for Processing ====

        def convert_time_to_decimal(value):
            if isinstance(value, str) and ('hr' in value or 'min' in value):
                hours = 0
                minutes = 0
                if 'hr' in value:
                    parts = value.split('hr')
                    hours = int(parts[0].strip())
                    if 'min' in parts[1]:
                        minutes = int(parts[1].replace('min', '').strip())
                elif 'min' in value:
                    minutes = int(value.replace('min', '').strip())
                return round(hours + (minutes / 60), 2)
            return value

        def format_time(value):
            if pd.notna(value):
                try:
                    value = str(value)
                    parts = value.split(':')
                    if len(parts) >= 2:
                        hour = parts[0].zfill(2)
                        minute = parts[1].zfill(2)
                        return f"{hour}:{minute}"
                except:
                    pass
            return value

        def process_value(value):
            new_value = convert_time_to_decimal(value)
            if new_value == value:
                new_value = format_time(value)
            try:
                if isinstance(new_value, (int, float)):
                    return format(round(float(new_value), 2), '.2f')
                if isinstance(new_value, str) and new_value.replace('.', '', 1).isdigit():
                    return format(round(float(new_value), 2), '.2f')
            except:
                pass
            return new_value

        df = df.applymap(process_value)

        # === Excel template setup ===
        template_path = os.path.join(settings.BASE_DIR, 'templates', 'template.xlsx')
        wb = load_workbook(template_path)
        ws = wb.active
        start_row = 2
        start_col = 1
        template_row = ws[start_row]

        # Write data into Excel with style
        for r_idx, row in enumerate(dataframe_to_rows(df, index=False, header=False), start=start_row):
            for c_idx, value in enumerate(row, start=start_col):
                cell = ws.cell(row=r_idx, column=c_idx, value=value)
                template_cell = template_row[c_idx - start_col]
                if template_cell.has_style:
                    cell.font = copy(template_cell.font)
                    cell.border = copy(template_cell.border)
                    cell.fill = copy(template_cell.fill)
                    cell.number_format = copy(template_cell.number_format)
                    cell.protection = copy(template_cell.protection)
                    cell.alignment = copy(template_cell.alignment)

        # Filename for export
        if start_date or end_date:
            file_name = f"{start_date or 'start'}_to_{end_date or 'end'}.xlsx"
        else:
            file_name = "alldata.xlsx"

        # Return Excel file as HTTP response
        response = HttpResponse(content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
        response['Content-Disposition'] = f'attachment; filename={file_name}'
        wb.save(response)
        return response

    except Exception as e:
        return HttpResponse(f"Export failed: {str(e)}", status=500)

class ImportDataView(FormView):
    template_name = 'import.html'
    form_class = ImportForm
    success_url = reverse_lazy('report_list')

    def form_valid(self, form):
        excel_file = form.cleaned_data['excel_file']

        try:
            df = pd.read_excel(excel_file)

            for _, row in df.iterrows():
                VAPProductionData.objects.create(  # Updated model reference
                    Date=row['Date'],  # Updated field name
                    PlantLoc=row['Plant Location'],  # Updated field name
                    Shift=row['Shift'],  # Updated field name
                    Product=row['Product'],  # Updated field name (direct assignment now)
                    TimeStart=row['Start Time'],  # Updated field name
                    TimeEnd=row['End Time'],  # Updated field name
                    BoilerTemp=row['Boiler Temp (°C)'],  # Updated field name
                    CookingOilTemp=row['Oil Temp (°C)'],  # Updated field name
                    OutputTemp=row['Output Temp (°C)'],  # Updated field name
                    InputTemp=row['Input Temp (°C)'],  # Updated field name
                    Source=row['Source'],  # Updated field name (direct assignment now)
                    FormaticStrokeMin=row['Formatic Strokes/Min'],  # Updated field name
                    ProdMinDescrip=row['Description']  # Updated field name (direct assignment now)
                )

            messages.success(self.request, 'Data imported successfully!')
        except Exception as e:
            messages.error(self.request, f'Error importing data: {str(e)}')

        return super().form_valid(form)
    
def create_production_record(request):
    if request.method == 'POST':
        form = ProductionForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('dashboard')  # Adjust to your dashboard URL name
    else:
        form = ProductionForm()
    return render(request, 'create.html', {'form': form})